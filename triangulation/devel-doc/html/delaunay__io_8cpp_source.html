<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>pmvs-triangulation: delaunay_io.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.6.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <img id="MSearchSelect" src="search/search.png"
             onmouseover="return searchBox.OnSearchSelectShow()"
             onmouseout="return searchBox.OnSearchSelectHide()"
             alt=""/>
        <input type="text" id="MSearchField" value="Search" accesskey="S"
             onfocus="searchBox.OnSearchFieldFocus(true)" 
             onblur="searchBox.OnSearchFieldFocus(false)" 
             onkeyup="searchBox.OnSearchFieldChange(event)"/>
        <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
    </ul>
  </div>
<h1>delaunay_io.cpp</h1><a href="delaunay__io_8cpp.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">// Copyright (c) INRIA (France) 2011, 2012, 2013</span>
<a name="l00003"></a>00003 <span class="comment">// </span>
<a name="l00004"></a>00004 <span class="comment">// This file is part of inria-mvs. You can redistribute it and/or</span>
<a name="l00005"></a>00005 <span class="comment">// modify it under the terms of the GNU General Public License.</span>
<a name="l00006"></a>00006 <span class="comment">// </span>
<a name="l00007"></a>00007 <span class="comment">// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE</span>
<a name="l00008"></a>00008 <span class="comment">// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.</span>
<a name="l00009"></a>00009 <span class="comment">// </span>
<a name="l00010"></a>00010 <span class="comment">// Author: Jean-Paul CHIEZE &lt;jean-paul.chieze@inria.fr&gt;</span>
<a name="l00011"></a>00011 <span class="comment">// </span>
<a name="l00013"></a>00013 <span class="comment"></span>
<a name="l00014"></a>00014 <span class="preprocessor">#include &quot;<a class="code" href="delaunay_8h.html">delaunay.h</a>&quot;</span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<a name="l00023"></a><a class="code" href="delaunay__io_8cpp.html#a9bdd03ec77e016ad50638e0b434143cc">00023</a> CGAL::Bbox_3 <a class="code" href="delaunay__io_8cpp.html#a9bdd03ec77e016ad50638e0b434143cc">ply_binary_data</a>(std::ifstream &amp;ifstr,TPoint &amp;points,std::vector&lt;Point&gt; &amp;normals,PointColor &amp;colors,std::vector&lt;Face&gt; &amp;faces,<span class="keywordtype">int</span> nbpts,<span class="keywordtype">int</span> nbfaces,<span class="keywordtype">int</span> nbflt, <span class="keywordtype">int</span> nbint) <span class="keywordflow">throw</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *){
<a name="l00024"></a>00024   <span class="keywordtype">float</span> x, y, z, nx, ny, nz;
<a name="l00025"></a>00025   <span class="keywordtype">double</span> xmin(1.e20), ymin(1.e20), zmin(1.e20), xmax(-1.e20), ymax(-1.e20), zmax(-1.e20);
<a name="l00026"></a>00026   <span class="keywordtype">int</span> r,g,b;
<a name="l00027"></a>00027   <span class="keywordtype">float</span> ftmp[6];
<a name="l00028"></a>00028   <span class="keywordtype">int</span> itmp[4];
<a name="l00029"></a>00029   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> colbuf[4];
<a name="l00030"></a>00030   <span class="keywordtype">int</span> j = points.size();
<a name="l00031"></a>00031   <span class="comment">// skip end of header line</span>
<a name="l00032"></a>00032   ifstr.getline((<span class="keywordtype">char</span> *)ftmp, 4);
<a name="l00033"></a>00033   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i &lt; nbpts;i++) {
<a name="l00034"></a>00034     ifstr.read((<span class="keywordtype">char</span> *)ftmp,nbflt * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00035"></a>00035     x = ftmp[0];y = ftmp[1]; z = ftmp[2];
<a name="l00036"></a>00036     <span class="keywordflow">if</span>(x &lt; xmin) xmin = x;
<a name="l00037"></a>00037     <span class="keywordflow">if</span>(y &lt; ymin) ymin = y;
<a name="l00038"></a>00038     <span class="keywordflow">if</span>(z &lt; zmin) zmin = z;
<a name="l00039"></a>00039     <span class="keywordflow">if</span>(x &gt; xmax) xmax = x;
<a name="l00040"></a>00040     <span class="keywordflow">if</span>(y &gt; ymax) ymax = y;
<a name="l00041"></a>00041     <span class="keywordflow">if</span>(z &gt; zmax) zmax = z;
<a name="l00042"></a>00042     points.push_back( std::make_pair(Point(x,y,z),j++));
<a name="l00043"></a>00043     <span class="keywordflow">if</span>(nbflt &gt; 3)
<a name="l00044"></a>00044       normals.push_back(Point(ftmp[3],ftmp[4],ftmp[5]));
<a name="l00045"></a>00045     <span class="keywordflow">if</span>(nbint &gt; 0) {
<a name="l00046"></a>00046       ifstr.read((<span class="keywordtype">char</span> *)colbuf,nbint * <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));
<a name="l00047"></a>00047       colors.push_back(CGAL::Color(colbuf[0],colbuf[1],colbuf[2]));
<a name="l00048"></a>00048     }
<a name="l00049"></a>00049   }
<a name="l00050"></a>00050   <span class="keywordflow">if</span>(nbfaces &gt; 0) {
<a name="l00051"></a>00051     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i &lt; nbfaces;i++) {
<a name="l00052"></a>00052       ifstr.read((<span class="keywordtype">char</span> *)colbuf,<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
<a name="l00053"></a>00053       ifstr.read((<span class="keywordtype">char</span> *)itmp,3 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00054"></a>00054       <span class="keywordflow">if</span>(colbuf[0] != 3)
<a name="l00055"></a>00055         <span class="keywordflow">throw</span> (<span class="stringliteral">&quot;PLY : bad facet size \n&quot;</span>);
<a name="l00056"></a>00056       faces.push_back(Face(itmp[0],itmp[1],itmp[2]));
<a name="l00057"></a>00057     }
<a name="l00058"></a>00058   }
<a name="l00059"></a>00059   <span class="keywordflow">return</span> CGAL::Bbox_3(xmin,ymin,zmin,xmax,ymax,zmax);
<a name="l00060"></a>00060 }
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 CGAL::Bbox_3 ply_ascii_data(std::ifstream &amp;ifstr,TPoint &amp;points,std::vector&lt;Point&gt; &amp;normals,PointColor &amp;colors,std::vector&lt;Face&gt; &amp;faces,<span class="keywordtype">int</span> nbpts,<span class="keywordtype">int</span> nbfaces,<span class="keywordtype">int</span> nbflt, <span class="keywordtype">int</span> nbint) <span class="keywordflow">throw</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *){
<a name="l00063"></a>00063   <span class="keywordtype">float</span> x, y, z, nx, ny, nz;
<a name="l00064"></a>00064   <span class="keywordtype">double</span> xmin(1.e20), ymin(1.e20), zmin(1.e20), xmax(-1.e20), ymax(-1.e20), zmax(-1.e20);
<a name="l00065"></a>00065   <span class="keywordtype">int</span> r,g,b,alpha;
<a name="l00066"></a>00066   <span class="keywordtype">int</span> j = points.size();
<a name="l00067"></a>00067   <span class="keywordflow">if</span>(nbfaces &gt; 0) <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;faces not yet supported in ascii mode\n&quot;</span>);
<a name="l00068"></a>00068   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i &lt; nbpts;i++) {
<a name="l00069"></a>00069     <span class="keywordflow">if</span> (ifstr.eof()) {
<a name="l00070"></a>00070       std::cout &lt;&lt; <span class="stringliteral">&quot;I = &quot;</span> &lt;&lt; i &lt;&lt; std::endl;
<a name="l00071"></a>00071       <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: points reading unexpected EOF\n&quot;</span>);
<a name="l00072"></a>00072     }
<a name="l00073"></a>00073     ifstr &gt;&gt; x &gt;&gt; y &gt;&gt; z;
<a name="l00074"></a>00074     <span class="keywordflow">if</span>(x &lt; xmin) xmin = x;
<a name="l00075"></a>00075     <span class="keywordflow">if</span>(y &lt; ymin) ymin = y;
<a name="l00076"></a>00076     <span class="keywordflow">if</span>(z &lt; zmin) zmin = z;
<a name="l00077"></a>00077     <span class="keywordflow">if</span>(x &gt; xmax) xmax = x;
<a name="l00078"></a>00078     <span class="keywordflow">if</span>(y &gt; ymax) ymax = y;
<a name="l00079"></a>00079     <span class="keywordflow">if</span>(z &gt; zmax) zmax = z;
<a name="l00080"></a>00080     <span class="keywordflow">if</span>(nbflt &gt; 3) {
<a name="l00081"></a>00081       ifstr &gt;&gt; nx &gt;&gt;ny &gt;&gt;nz;
<a name="l00082"></a>00082       normals.push_back(Point(nx,ny,nz));
<a name="l00083"></a>00083     }
<a name="l00084"></a>00084     <span class="keywordflow">if</span>(nbint &gt; 0) {
<a name="l00085"></a>00085       ifstr &gt;&gt; r &gt;&gt; g &gt;&gt; b;
<a name="l00086"></a>00086       <span class="keywordflow">if</span>(nbint == 4)
<a name="l00087"></a>00087         ifstr &gt;&gt; alpha;
<a name="l00088"></a>00088       colors.push_back(CGAL::Color(r,g,b));
<a name="l00089"></a>00089     } <span class="keywordflow">else</span>
<a name="l00090"></a>00090       colors.push_back(CGAL::Color(128,128,128));
<a name="l00091"></a>00091     points.push_back( std::make_pair(Point(x,y,z),j++));
<a name="l00092"></a>00092   }
<a name="l00093"></a>00093   <span class="keywordflow">return</span> CGAL::Bbox_3(xmin,ymin,zmin,xmax,ymax,zmax);
<a name="l00094"></a>00094 }
<a name="l00095"></a>00095 
<a name="l00096"></a>00096 CGAL::Bbox_3 read_all_ply(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename,TPoint &amp;points,std::vector&lt;Point&gt; &amp;normals,PointColor &amp;colors,std::vector&lt;Face&gt; &amp;faces,<span class="keywordtype">char</span> **comment,<span class="keywordtype">bool</span> with_faces) <span class="keywordflow">throw</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *){
<a name="l00097"></a>00097   std::ifstream ifstr;
<a name="l00098"></a>00098   ifstr.open(filename);
<a name="l00099"></a>00099   <span class="keywordflow">if</span>(! ifstr.good()) {
<a name="l00100"></a>00100     std::cerr &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; filename &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00101"></a>00101     <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_data: cannot open file&quot;</span>);
<a name="l00102"></a>00102   }
<a name="l00103"></a>00103   <span class="keywordtype">char</span> tmp[1024];
<a name="l00104"></a>00104   std::string name, str1;
<a name="l00105"></a>00105   <span class="keywordtype">int</span> nbpts(0), nbfaces(0);
<a name="l00106"></a>00106   <span class="keywordtype">int</span> nbflt = 0, nbint = 0;
<a name="l00107"></a>00107   ifstr &gt;&gt; name;
<a name="l00108"></a>00108   <span class="keywordflow">if</span>(name != <span class="stringliteral">&quot;ply&quot;</span>) <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: bad ply header\n&quot;</span>);
<a name="l00109"></a>00109   ifstr &gt;&gt; name &gt;&gt; str1;
<a name="l00110"></a>00110   <span class="keywordtype">bool</span> ascii_mode = <span class="keyword">true</span>;
<a name="l00111"></a>00111   <span class="keywordflow">if</span>(name != <span class="stringliteral">&quot;format&quot;</span>)  <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: incorrect ply format\n&quot;</span>);
<a name="l00112"></a>00112   <span class="keywordflow">if</span> (str1 != <span class="stringliteral">&quot;ascii&quot;</span>) {
<a name="l00113"></a>00113     <span class="keywordflow">if</span>(str1 == <span class="stringliteral">&quot;binary_little_endian&quot;</span>) ascii_mode = <span class="keyword">false</span>;
<a name="l00114"></a>00114     <span class="keywordflow">else</span>
<a name="l00115"></a>00115       <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: incorrect ply format\n&quot;</span>);
<a name="l00116"></a>00116   }
<a name="l00117"></a>00117   ifstr &gt;&gt; str1;
<a name="l00118"></a>00118   <span class="keywordflow">while</span>(1) { <span class="comment">// read options</span>
<a name="l00119"></a>00119     ifstr &gt;&gt; name;
<a name="l00120"></a>00120     <span class="keywordflow">if</span> (name == <span class="stringliteral">&quot;end_header&quot;</span>) <span class="keywordflow">break</span>;
<a name="l00121"></a>00121     ifstr &gt;&gt; str1;
<a name="l00122"></a>00122     <span class="keywordflow">if</span>(name == <span class="stringliteral">&quot;element&quot;</span>) {
<a name="l00123"></a>00123       <span class="keywordtype">int</span> itmp;
<a name="l00124"></a>00124       ifstr &gt;&gt; itmp;
<a name="l00125"></a>00125       <span class="keywordflow">if</span>(str1 == <span class="stringliteral">&quot;vertex&quot;</span>)
<a name="l00126"></a>00126         nbpts = itmp;
<a name="l00127"></a>00127       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str1 == <span class="stringliteral">&quot;face&quot;</span>)
<a name="l00128"></a>00128         nbfaces = itmp;
<a name="l00129"></a>00129       <span class="keywordflow">else</span> <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: unexpected element&quot;</span>);
<a name="l00130"></a>00130     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(name == <span class="stringliteral">&quot;property&quot;</span>) {
<a name="l00131"></a>00131       std::string str2;
<a name="l00132"></a>00132       ifstr &gt;&gt; str2;
<a name="l00133"></a>00133       <span class="keywordflow">if</span>(str1 == <span class="stringliteral">&quot;float&quot;</span>) nbflt++;
<a name="l00134"></a>00134       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (str1 == <span class="stringliteral">&quot;uchar&quot;</span>) nbint++;
<a name="l00135"></a>00135       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(str1 == <span class="stringliteral">&quot;list&quot;</span>) {
<a name="l00136"></a>00136         ifstr.getline(tmp, 256);
<a name="l00137"></a>00137         <span class="keywordflow">continue</span>;
<a name="l00138"></a>00138       }
<a name="l00139"></a>00139       <span class="keywordflow">else</span> <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: unexpected property type\n&quot;</span>);
<a name="l00140"></a>00140     } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(name == <span class="stringliteral">&quot;comment&quot;</span>) {
<a name="l00141"></a>00141       ifstr.getline(tmp, 1024);
<a name="l00142"></a>00142       tmp[1023] = 0;
<a name="l00143"></a>00143       <span class="keywordflow">if</span>(comment != NULL) {
<a name="l00144"></a>00144         <span class="keywordtype">char</span> *p = <span class="keyword">new</span> <span class="keywordtype">char</span>[strlen(tmp)];
<a name="l00145"></a>00145         strcpy(p,tmp);
<a name="l00146"></a>00146         *comment = p;
<a name="l00147"></a>00147       }
<a name="l00148"></a>00148       <span class="keywordflow">continue</span>;
<a name="l00149"></a>00149     } <span class="keywordflow">else</span> {
<a name="l00150"></a>00150       std::cout &lt;&lt; <span class="stringliteral">&quot;ERR &quot;</span> &lt;&lt; name &lt;&lt; std::endl;
<a name="l00151"></a>00151       <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: unexpected keyword\n&quot;</span>);
<a name="l00152"></a>00152     }
<a name="l00153"></a>00153     <span class="keywordflow">if</span> (ifstr.eof()) <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: unexpected EOF\n&quot;</span>);
<a name="l00154"></a>00154   }
<a name="l00155"></a>00155   <span class="keywordflow">if</span>(!with_faces &amp;&amp; nbfaces != 0) <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: unexpected non nul faces nb\n&quot;</span>);
<a name="l00156"></a>00156 
<a name="l00157"></a>00157   <span class="keywordflow">if</span>((nbflt != 3 &amp;&amp; nbflt != 6) || (nbint != 0 &amp;&amp; nbint != 3 &amp;&amp; nbint != 4)) 
<a name="l00158"></a>00158     <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_ply: unexpected data structure\n&quot;</span>);
<a name="l00159"></a>00159   CGAL::Bbox_3 bb;
<a name="l00160"></a>00160   <span class="keywordflow">if</span>(ascii_mode)
<a name="l00161"></a>00161     bb = ply_ascii_data(ifstr,points,normals,colors,faces,nbpts,nbfaces,nbflt,nbint);
<a name="l00162"></a>00162   <span class="keywordflow">else</span>
<a name="l00163"></a>00163     bb = <a class="code" href="delaunay__io_8cpp.html#a9bdd03ec77e016ad50638e0b434143cc">ply_binary_data</a>(ifstr,points,normals,colors,faces,nbpts,nbfaces,nbflt,nbint);
<a name="l00164"></a>00164   ifstr.close();
<a name="l00165"></a>00165   <span class="keywordflow">return</span> bb;
<a name="l00166"></a>00166 }
<a name="l00170"></a><a class="code" href="delaunay__io_8cpp.html#a13836f26cc1d5f874661710b7ea6699b">00170</a> CGAL::Bbox_3 <a class="code" href="delaunay_8h.html#a13836f26cc1d5f874661710b7ea6699b" title="read a ply file containing only points, optionnaly with colors and normals">read_ply</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename,TPoint &amp;points,std::vector&lt;Point&gt; &amp;normals,PointColor &amp;colors) <span class="keywordflow">throw</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *){
<a name="l00171"></a>00171   std::vector&lt;Face&gt; faces;
<a name="l00172"></a>00172   <span class="keywordflow">return</span> read_all_ply(filename,points,normals,colors,faces,NULL,<span class="keyword">false</span>);
<a name="l00173"></a>00173 }
<a name="l00177"></a><a class="code" href="delaunay__io_8cpp.html#ae5d5d2a95cf3f0d0133f3f1e3eaaa4b4">00177</a> CGAL::Bbox_3 <a class="code" href="delaunay_8h.html#a13836f26cc1d5f874661710b7ea6699b" title="read a ply file containing only points, optionnaly with colors and normals">read_ply</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename,TPoint &amp;points,std::vector&lt;Point&gt; &amp;normals,PointColor &amp;colors,std::vector&lt;Face&gt; &amp;faces,<span class="keywordtype">char</span> **comment) <span class="keywordflow">throw</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *){
<a name="l00178"></a>00178   <span class="keywordflow">return</span> read_all_ply(filename,points,normals,colors,faces,comment,<span class="keyword">true</span>);
<a name="l00179"></a>00179 }
<a name="l00180"></a>00180 
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="comment">/* path file :</span>
<a name="l00183"></a>00183 <span class="comment">1st line = PATCHES</span>
<a name="l00184"></a>00184 <span class="comment">2nd : nb of patches</span>
<a name="l00185"></a>00185 <span class="comment">9 lignes per patch :</span>
<a name="l00186"></a>00186 <span class="comment">  - PATHCES</span>
<a name="l00187"></a>00187 <span class="comment">  - points homogeneous coords : x y z 1</span>
<a name="l00188"></a>00188 <span class="comment">  - normal in homogeneous coords : nx ny nz 0</span>
<a name="l00189"></a>00189 <span class="comment">  - m_ncc m_dscale m_ascale</span>
<a name="l00190"></a>00190 <span class="comment">  - nb of associated images</span>
<a name="l00191"></a>00191 <span class="comment">  - list of associated images indices</span>
<a name="l00192"></a>00192 <span class="comment">  - nb of images where the patch is visible</span>
<a name="l00193"></a>00193 <span class="comment">  - list of images or empty line</span>
<a name="l00194"></a>00194 <span class="comment">  - empty line</span>
<a name="l00195"></a>00195 <span class="comment"> */</span>
<a name="l00196"></a>00196 
<a name="l00197"></a>00197 <span class="keywordtype">void</span> read_patches(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename,<span class="keywordtype">int</span> firstpoint,<span class="keywordtype">int</span> nbcams,TPoint &amp;points, std::map&lt;int, VisiblePatches *&gt; &amp;image_patches, <span class="keywordtype">bool</span> read_points) <span class="keywordflow">throw</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *){
<a name="l00198"></a>00198   std::ifstream ifstr;
<a name="l00199"></a>00199   ifstr.open(filename);
<a name="l00200"></a>00200   <span class="keywordflow">if</span>(! ifstr.good())
<a name="l00201"></a>00201     <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_data: cannot open file&quot;</span>);
<a name="l00202"></a>00202   <span class="keywordtype">char</span> tmp[256];
<a name="l00203"></a>00203   std::string name;
<a name="l00204"></a>00204   <span class="keywordtype">int</span> nbpatches;
<a name="l00205"></a>00205   <span class="keywordtype">int</span> n;
<a name="l00206"></a>00206   <span class="keywordtype">float</span> x, y, z, w;
<a name="l00207"></a>00207   ifstr &gt;&gt; name;
<a name="l00208"></a>00208   <span class="keywordflow">if</span>(name != <span class="stringliteral">&quot;PATCHES&quot;</span>) <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_patches: bad header\n&quot;</span>);
<a name="l00209"></a>00209   ifstr &gt;&gt; nbpatches;
<a name="l00210"></a>00210   <span class="keywordtype">int</span> j = firstpoint;
<a name="l00211"></a>00211   <span class="keywordtype">int</span> nbvis = 0;
<a name="l00212"></a>00212   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0;k &lt; nbpatches;k++) {
<a name="l00213"></a>00213     <span class="keywordflow">if</span> (ifstr.eof()) <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_patches: unexpected EOF\n&quot;</span>);
<a name="l00214"></a>00214     ifstr &gt;&gt; name;
<a name="l00215"></a>00215     <span class="keywordflow">if</span>(name != <span class="stringliteral">&quot;PATCHS&quot;</span>) <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_patches: bad patch header\n&quot;</span>);
<a name="l00216"></a>00216     ifstr &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; w;
<a name="l00217"></a>00217     <span class="keywordflow">if</span> (read_points) points.push_back( std::make_pair(Point(x,y,z),j));
<a name="l00218"></a>00218     ifstr &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; w;  <span class="comment">// normal</span>
<a name="l00219"></a>00219     ifstr &gt;&gt; x &gt;&gt; y &gt;&gt; z;
<a name="l00220"></a>00220     ifstr &gt;&gt; n; <span class="comment">// nb of associated images</span>
<a name="l00221"></a>00221     <span class="keywordflow">if</span>(n == 0) <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_patches: nb of images is not &gt; 0\n&quot;</span>);
<a name="l00222"></a>00222     nbvis++;
<a name="l00223"></a>00223     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; n; i++) {
<a name="l00224"></a>00224       <span class="keywordtype">int</span> v;
<a name="l00225"></a>00225       ifstr &gt;&gt; v;
<a name="l00226"></a>00226       <span class="keywordflow">if</span> (v &gt;= nbcams) <span class="keywordflow">continue</span>;  <span class="comment">// for tests</span>
<a name="l00227"></a>00227       <span class="keywordflow">if</span>(image_patches.count(v) == 0)
<a name="l00228"></a>00228         image_patches[v] = <span class="keyword">new</span> VisiblePatches();
<a name="l00229"></a>00229       image_patches[v]-&gt;push_back(j);
<a name="l00230"></a>00230     }
<a name="l00231"></a>00231     ifstr &gt;&gt; n;  <span class="comment">// nb of visibility images</span>
<a name="l00232"></a>00232     ifstr.ignore(256,<span class="charliteral">&#39;\n&#39;</span>);
<a name="l00233"></a>00233     ifstr.ignore(256,<span class="charliteral">&#39;\n&#39;</span>);
<a name="l00234"></a>00234 
<a name="l00235"></a>00235     ifstr.ignore(256,<span class="charliteral">&#39;\n&#39;</span>); <span class="comment">// empty line</span>
<a name="l00236"></a>00236     j++;
<a name="l00237"></a>00237   }
<a name="l00238"></a>00238   ifstr.close();
<a name="l00239"></a>00239   <span class="comment">//  std::cout &lt;&lt; nbvis &lt;&lt; &quot; / &quot; &lt;&lt; nbpatches &lt;&lt; &quot; visibles&quot; &lt;&lt; std::endl;</span>
<a name="l00240"></a>00240 }
<a name="l00241"></a>00241 <span class="keyword">static</span> <span class="keywordtype">int</span> cmp(<span class="keyword">const</span> <span class="keywordtype">void</span> *i1, <span class="keyword">const</span> <span class="keywordtype">void</span> *i2) { <span class="keywordflow">return</span> *(<span class="keywordtype">int</span> *)i1 &gt; *(<span class="keywordtype">int</span> *)i2;}
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keywordtype">void</span> get_patches(std::ifstream &amp;iFileT,<span class="keywordtype">int</span> nbcams,std::map&lt;int, VisiblePatches*&gt; &amp;image_patches,TPoint &amp;bad_cameras,<span class="keywordtype">int</span> data_mode)  <span class="keywordflow">throw</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *){
<a name="l00244"></a>00244   <span class="keywordflow">if</span>((data_mode &amp; (CG_PATCHES | CG_BADCAMS)) == 0) <span class="keywordflow">return</span>;
<a name="l00245"></a>00245   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i &lt; nbcams;i++) {
<a name="l00246"></a>00246     <span class="keywordtype">int</span> tmp[2];
<a name="l00247"></a>00247     iFileT.read((<span class="keywordtype">char</span> *)tmp,<span class="keyword">sizeof</span>(tmp));
<a name="l00248"></a>00248     <span class="keywordtype">int</span> n = tmp[1];
<a name="l00249"></a>00249     <span class="keywordtype">int</span> icam = tmp[0];
<a name="l00250"></a>00250     <span class="keywordflow">if</span>(data_mode &amp; CG_PATCHES) {
<a name="l00251"></a>00251       image_patches[icam] = <span class="keyword">new</span> VisiblePatches();
<a name="l00252"></a>00252       <span class="keywordtype">int</span> *pi0 = <span class="keyword">new</span> <span class="keywordtype">int</span>[n];
<a name="l00253"></a>00253       <span class="keywordtype">int</span> *pi = pi0;
<a name="l00254"></a>00254       iFileT.read((<span class="keywordtype">char</span> *)pi,n * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00255"></a>00255       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0;j &lt; n;j++)
<a name="l00256"></a>00256         image_patches[icam]-&gt;push_back(*pi++);
<a name="l00257"></a>00257       <span class="keyword">delete</span>[] pi0;
<a name="l00258"></a>00258     } <span class="keywordflow">else</span> {
<a name="l00259"></a>00259       iFileT.seekg(n * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),std::ios_base::cur);
<a name="l00260"></a>00260     }
<a name="l00261"></a>00261   }
<a name="l00262"></a>00262   <span class="keywordflow">if</span>(! (data_mode &amp; CG_BADCAMS)) <span class="keywordflow">return</span>;
<a name="l00263"></a>00263   <span class="keywordtype">int</span> nb_badcams;
<a name="l00264"></a>00264   iFileT.read((<span class="keywordtype">char</span> *)&amp;nb_badcams,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00265"></a>00265   <span class="keywordtype">float</span> *pf0 = <span class="keyword">new</span> <span class="keywordtype">float</span>[3 * nb_badcams];
<a name="l00266"></a>00266   <span class="keywordtype">float</span> *pf = pf0;
<a name="l00267"></a>00267   <span class="keywordtype">int</span> *pi0 = <span class="keyword">new</span> <span class="keywordtype">int</span>[nb_badcams];
<a name="l00268"></a>00268   <span class="keywordtype">int</span> *pi = pi0;
<a name="l00269"></a>00269   iFileT.read((<span class="keywordtype">char</span> *)pf0,3 * nb_badcams * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00270"></a>00270   iFileT.read((<span class="keywordtype">char</span> *)pi0,nb_badcams * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00271"></a>00271   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i &lt; nb_badcams;i++, pf += 3, pi++) {
<a name="l00272"></a>00272     bad_cameras.push_back(std::make_pair(Point(*pf,*(pf+1),*(pf+2)),*pi));
<a name="l00273"></a>00273   }
<a name="l00274"></a>00274   <span class="keyword">delete</span>[] pf0;
<a name="l00275"></a>00275   <span class="keyword">delete</span>[] pi0;
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="keywordtype">void</span> read_cgal_data(<span class="keywordtype">char</span> *file,Delaunay &amp;T,PointColor &amp;pcolors,std::vector&lt;Point&gt; &amp;normals,CGAL::Bbox_3 &amp;bb,<span class="keywordtype">int</span> *nbcams,<span class="keywordtype">int</span> **cams_index,std::map&lt;int, VisiblePatches*&gt; &amp;image_patches,TPoint &amp;bad_cameras,<span class="keywordtype">int</span> data_mode,<span class="keywordtype">float</span> *edge_mean,<span class="keywordtype">float</span>*tetra_coefs) <span class="keywordflow">throw</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *){
<a name="l00279"></a>00279   std::ifstream iFileT;
<a name="l00280"></a>00280   iFileT.open(file);
<a name="l00281"></a>00281   <span class="keywordflow">if</span>(! iFileT.good()) {
<a name="l00282"></a>00282     std::cerr &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; file &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00283"></a>00283     <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_cgal_data: cannot open file&quot;</span>);
<a name="l00284"></a>00284   }
<a name="l00285"></a>00285   CGAL::set_binary_mode(iFileT);
<a name="l00286"></a>00286   <span class="keywordtype">char</span> tmp[4];
<a name="l00287"></a>00287   iFileT.read(tmp,4);
<a name="l00288"></a>00288   <span class="keywordflow">if</span>(strncmp(tmp,file_version,4) != 0)
<a name="l00289"></a>00289     <span class="keywordflow">throw</span> (<span class="stringliteral">&quot;Incompatible version for CGAL file\n&quot;</span>);
<a name="l00290"></a>00290   <span class="comment">// delaunay</span>
<a name="l00291"></a>00291   iFileT &gt;&gt; T;
<a name="l00292"></a>00292   Delaunay::Finite_vertices_iterator it;
<a name="l00293"></a>00293   <span class="keywordtype">int</span> i = 0;
<a name="l00294"></a>00294   <span class="comment">// bbox + tetra_coefs</span>
<a name="l00295"></a>00295   <span class="keywordtype">float</span> box[6];
<a name="l00296"></a>00296   iFileT.read((<span class="keywordtype">char</span> *)box,<span class="keyword">sizeof</span>(box));
<a name="l00297"></a>00297   bb = CGAL::Bbox_3(box[0],box[1],box[2],box[3],box[4],box[5]);
<a name="l00298"></a>00298   <span class="keywordtype">float</span> ftmp[3];
<a name="l00299"></a>00299   iFileT.read((<span class="keywordtype">char</span> *)ftmp,3 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00300"></a>00300   *edge_mean = ftmp[0];
<a name="l00301"></a>00301   tetra_coefs[0] = ftmp[1];
<a name="l00302"></a>00302   tetra_coefs[1] = ftmp[2];
<a name="l00303"></a>00303   <span class="comment">// nb valid cameras</span>
<a name="l00304"></a>00304   iFileT.read((<span class="keywordtype">char</span> *)nbcams,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00305"></a>00305   <span class="comment">// colors of points</span>
<a name="l00306"></a>00306   <span class="keywordflow">for</span>(it = T.finite_vertices_begin();it != T.finite_vertices_end();it++,i++) {
<a name="l00307"></a>00307     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp[3];
<a name="l00308"></a>00308     iFileT.read((<span class="keywordtype">char</span> *)tmp,<span class="keyword">sizeof</span>(tmp));
<a name="l00309"></a>00309     it-&gt;info() = i;
<a name="l00310"></a>00310     pcolors.push_back(CGAL::Color(tmp[0],tmp[1],tmp[2]));
<a name="l00311"></a>00311   }
<a name="l00312"></a>00312   <span class="keywordtype">bool</span> with_normals;
<a name="l00313"></a>00313   <span class="comment">// normals of points if available</span>
<a name="l00314"></a>00314   iFileT.read((<span class="keywordtype">char</span> *)&amp;with_normals,<span class="keyword">sizeof</span>(with_normals));
<a name="l00315"></a>00315   <span class="keywordflow">if</span>(with_normals) {
<a name="l00316"></a>00316     <span class="keywordflow">for</span>(it = T.finite_vertices_begin();it != T.finite_vertices_end();it++) {
<a name="l00317"></a>00317       <span class="keywordtype">float</span> tmp[3];
<a name="l00318"></a>00318       iFileT.read((<span class="keywordtype">char</span> *)tmp,<span class="keyword">sizeof</span>(tmp));
<a name="l00319"></a>00319       normals.push_back(Point(tmp[0],tmp[1],tmp[2]));
<a name="l00320"></a>00320     }
<a name="l00321"></a>00321   }
<a name="l00322"></a>00322   <span class="comment">// cameras indexes</span>
<a name="l00323"></a>00323   <span class="keywordtype">int</span> *cams = <span class="keyword">new</span> <span class="keywordtype">int</span>[*nbcams * 2];
<a name="l00324"></a>00324   iFileT.read((<span class="keywordtype">char</span> *)cams,*nbcams * 2 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00325"></a>00325   Delaunay::Finite_cells_iterator cit;
<a name="l00326"></a>00326   <span class="keywordflow">for</span> (cit = T.finite_cells_begin(); cit != T.finite_cells_end(); ++cit) {
<a name="l00327"></a>00327     iFileT.read((<span class="keywordtype">char</span> *)&amp;i,<span class="keyword">sizeof</span>(i));
<a name="l00328"></a>00328     cit-&gt;info() = i;
<a name="l00329"></a>00329   }
<a name="l00330"></a>00330   get_patches(iFileT,*nbcams,image_patches,bad_cameras,data_mode);
<a name="l00331"></a>00331   iFileT.close();
<a name="l00332"></a>00332   <span class="comment">// return sorted list oy cam indexes</span>
<a name="l00333"></a>00333   
<a name="l00334"></a>00334   *cams_index = cams;
<a name="l00335"></a>00335   qsort(cams,*nbcams,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),cmp);
<a name="l00336"></a>00336 }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="keywordtype">void</span> read_cgal_xdata(<span class="keywordtype">char</span> *file,<span class="keywordtype">int</span> *nbcams,<span class="keywordtype">int</span> **cams_index,CGAL::Bbox_3 &amp;bb,std::map&lt;int, VisiblePatches*&gt; &amp;image_patches,TPoint &amp;bad_cameras,<span class="keywordtype">int</span> data_mode,<span class="keywordtype">float</span> *edge_mean,<span class="keywordtype">float</span>*tetra_coefs)  <span class="keywordflow">throw</span>(<span class="keyword">const</span> <span class="keywordtype">char</span> *){
<a name="l00340"></a>00340   std::ifstream iFileT;
<a name="l00341"></a>00341   iFileT.open(file);
<a name="l00342"></a>00342   <span class="keywordflow">if</span>(! iFileT.good()) {
<a name="l00343"></a>00343     std::cerr &lt;&lt; <span class="stringliteral">&quot;File &quot;</span> &lt;&lt; file &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;
<a name="l00344"></a>00344     <span class="keywordflow">throw</span>(<span class="stringliteral">&quot;read_cgal_xdata: cannot open file&quot;</span>);
<a name="l00345"></a>00345   }
<a name="l00346"></a>00346   CGAL::set_binary_mode(iFileT);
<a name="l00347"></a>00347   <span class="keywordtype">char</span> tmp[4];
<a name="l00348"></a>00348   iFileT.read(tmp,4);
<a name="l00349"></a>00349   <span class="keywordflow">if</span>(strncmp(tmp,file_version,4) != 0)
<a name="l00350"></a>00350     <span class="keywordflow">throw</span> (<span class="stringliteral">&quot;Incompatible version for CGAL file\n&quot;</span>);
<a name="l00351"></a>00351   Delaunay T;
<a name="l00352"></a>00352   iFileT &gt;&gt; T;
<a name="l00353"></a>00353   <span class="keywordtype">float</span> box[6];
<a name="l00354"></a>00354   iFileT.read((<span class="keywordtype">char</span> *)box,<span class="keyword">sizeof</span>(box));
<a name="l00355"></a>00355   bb = CGAL::Bbox_3(box[0],box[1],box[2],box[3],box[4],box[5]);
<a name="l00356"></a>00356   <span class="keywordtype">float</span> ftmp[3];
<a name="l00357"></a>00357   iFileT.read((<span class="keywordtype">char</span> *)ftmp,3 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>));
<a name="l00358"></a>00358   *edge_mean = ftmp[0];
<a name="l00359"></a>00359   tetra_coefs[0] = ftmp[1];
<a name="l00360"></a>00360   tetra_coefs[1] = ftmp[2];
<a name="l00361"></a>00361   iFileT.read((<span class="keywordtype">char</span> *)nbcams,<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00362"></a>00362   <span class="keywordtype">int</span> nbv = std::distance(T.finite_vertices_begin(),T.finite_vertices_end());
<a name="l00363"></a>00363   <span class="comment">// colors</span>
<a name="l00364"></a>00364   iFileT.seekg(nbv * 3,std::ios_base::cur);
<a name="l00365"></a>00365   <span class="comment">// normals</span>
<a name="l00366"></a>00366   <span class="keywordtype">bool</span> with_normals;
<a name="l00367"></a>00367   iFileT.read((<span class="keywordtype">char</span> *)&amp;with_normals,<span class="keyword">sizeof</span>(with_normals));
<a name="l00368"></a>00368   <span class="keywordflow">if</span>(with_normals)
<a name="l00369"></a>00369     iFileT.seekg(nbv * 3 * <span class="keyword">sizeof</span>(<span class="keywordtype">float</span>),std::ios_base::cur);
<a name="l00370"></a>00370   <span class="comment">// cams index</span>
<a name="l00371"></a>00371   <span class="keywordtype">int</span> *cams = <span class="keyword">new</span> <span class="keywordtype">int</span>[2 * *nbcams];
<a name="l00372"></a>00372   iFileT.read((<span class="keywordtype">char</span> *)cams,*nbcams * 2 * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
<a name="l00373"></a>00373   *cams_index = cams;
<a name="l00374"></a>00374   <span class="keywordtype">int</span> nbcells = std::distance(T.finite_cells_begin(),T.finite_cells_end());
<a name="l00375"></a>00375   iFileT.seekg(nbcells * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>),std::ios_base::cur);
<a name="l00376"></a>00376   get_patches(iFileT,*nbcams,image_patches,bad_cameras,data_mode);
<a name="l00377"></a>00377 }
<a name="l00378"></a>00378 
</pre></div></div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address style="text-align: right;"><small>Generated on Fri Aug 23 14:41:21 2013 for pmvs-triangulation by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
